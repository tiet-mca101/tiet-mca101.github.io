#+startup: beamer
#+title: mca101 : computer graphics
#+subtitle: 2d geometry representation
#+email: bv.raghav@thapar.edu
#+options: H:3 toc:nil author:nil date:nil

#+include: preamble.org
#+beamer_header: \setbeamercovered{transparent}
#+beamer_header: \makeatletter
#+beamer_header: \newcommand{\RemoveAlgoNumber}{\renewcommand{\fnum@algocf}{\AlCapSty{\AlCapFnt\algorithmcfname}}}
#+beamer_header: \newcommand{\RevertAlgoNumber}{\algocf@resetfnum}
#+beamer_header: \makeatother
#+beamer_header: \SetKwProg{Fn}{Function}{ is}{end}
#+beamer_header: \SetKwBlock{Cont}{}{end}

* 2d geometry --- introduction

** Straight Lines

*** $y = mx + c$

\begin{align}
  \notag
  y = f(x) &= mx + c
\end{align}

#+attr_latex: :width 0.3\linewidth
[[file:images/st-line.png]]

*** parametric form

****                                                           :B_columns:
:PROPERTIES:
:BEAMER_env: columns
:END:

*****                                                    :B_column:BMCOL:
:PROPERTIES:
:BEAMER_env: column
:BEAMER_col: .5
:END:
For any two vectors $\mathbf{u},\mathbf{v}\in V$, a
point on the line segment joining them is given
parameterised by $t\in[0,1]$, as

\begin{align}
  \notag
  \mathbf{p} = f(t) &= (1-t)\mathbf{u} + t\mathbf{v}
\end{align}

*** parametric form

****                                                           :B_columns:
:PROPERTIES:
:BEAMER_env: columns
:END:

*****                                                    :B_column:BMCOL:
:PROPERTIES:
:BEAMER_env: column
:BEAMER_col: .5
:END:
Any point on a line in the direction of unit vector
$\mathbf{u}:\|\mathbf{u}\|_2^2=1$, and an incident
point $\mathbf{p}_0$ may be given parameterised by
$t\in\mathbb{R}$ as,

\begin{align}
  \notag
  \mathbf{p} = f(t) &= \mathbf{p}_0 + t\mathbf{u}
\end{align}

*** hesse normal form

****                                                           :B_columns:
:PROPERTIES:
:BEAMER_env: columns
:END:

*****                                                    :B_column:BMCOL:
:PROPERTIES:
:BEAMER_env: column
:BEAMER_col: .5
:END:

#+attr_latex: :width 0.7\linewidth
[[file:images/Hesse_normalenform.svg.png]]

Distance from the origin $O$ to the line $E$ calculated
with the Hesse normal form. Normal vector in red, line
in green, point O shown in blue.

*****                                                    :B_column:BMCOL:
:PROPERTIES:
:BEAMER_env: column
:BEAMER_col: .6
:END:

Given, \\
Normal to the line
$\mathbf{n}_0:\|\mathbf{n}_0\|_2^2=1$, and \\
its distance from origin, $d$;

\vspace{\baselineskip}
The point on the line is given implicitly as the locus
of all points $\mathbf{p}$ that satisfy,

\begin{align}
  \notag
  \mathbf{n}_0 \cdot \mathbf{p} - d &= 0
\end{align}

** Conics


*** circle

****                                                           :B_columns:
:PROPERTIES:
:BEAMER_env: columns
:END:

*****                                                    :B_column:BMCOL:
:PROPERTIES:
:BEAMER_env: column
:BEAMER_col: .4
:END:

#+caption: Image Courtesy: [[https://en.wikipedia.org/wiki/File:Circle-withsegments.svg][Wikipedia]]
[[file:images/Circle-withsegments.svg.png]]

*****                                                    :B_column:BMCOL:
:PROPERTIES:
:BEAMER_env: column
:BEAMER_col: .6
:END:
Implicit Form:
\begin{align}
  \notag
  f\left(\begin{matrix}x\\y\end{matrix}\right)
  &= x^2 + y^2 - r^2 = 0
\end{align}

Parametric Form:
\begin{align}
  \notag
  f(r,t)
  &= \begin{bmatrix}r\cos t\\r\sin t\end{bmatrix}
\end{align}
*** ellipse

****                                                           :B_columns:
:PROPERTIES:
:BEAMER_env: columns
:END:

*****                                                    :B_column:BMCOL:
:PROPERTIES:
:BEAMER_env: column
:BEAMER_col: .4
:END:

#+caption: Image Courtesy: [[https://commons.wikimedia.org/wiki/File:Ellipse-param.svg][Wikipedia]]
[[file:images/Ellipse-param.svg.png]]

*****                                                    :B_column:BMCOL:
:PROPERTIES:
:BEAMER_env: column
:BEAMER_col: .6
:END:
Standard form
\begin{align}
  \notag
  f\left( \begin{matrix}x\\y\end{matrix} \right)
  &= \frac{x^2}{a^2} + \frac{y^2}{b^2} - 1 = 0
\end{align}

Parametric Form
\begin{align}
  \notag
  f(t;a,b) &= \begin{bmatrix}
    a\cos t \\ b \sin t
  \end{bmatrix}
\end{align}


* mid-point algorithm

** Fundamentals

*** problem


****                                                           :B_columns:
:PROPERTIES:
:BEAMER_env: columns
:END:

*****                                                    :B_column:BMCOL:
:PROPERTIES:
:BEAMER_env: column
:BEAMER_col: .5
:END:
In a quantised (pixelated or discrete) 2d plane, find
the set of points that visually approximate a given
curve, say a straight line or a conic.

*** method

****                                                           :B_columns:
:PROPERTIES:
:BEAMER_env: columns
:END:

*****                                                    :B_column:BMCOL:
:PROPERTIES:
:BEAMER_env: column
:BEAMER_col: .5
:END:
Iteratively, increment along one axes, \\
with respect to which, the slope of the curve is
gentle.

#+latex: {\vspace{\baselineskip}}
Decide whether it is required to increment along the
perpendicular axis or not.

#+latex: {\vspace{\baselineskip}}
Increment if required.

*** example
#+attr_latex: :width 0.8\linewidth
[[file:images/basic-midpoint-algo.png]]
  
*** example
#+attr_latex: :width \linewidth
[[file:images/0--mid-point-algo_annotated.png]]

*** conditions for application of mid-point algorithm

****                                                           :B_columns:
:PROPERTIES:
:BEAMER_env: columns
:END:

*****                                                    :B_column:BMCOL:
:PROPERTIES:
:BEAMER_env: column
:BEAMER_col: .45
:END:
Mid-point algorithm is applicable to a curve within a
given finite interval, *iff*

1. The curve increases monotonically;
2. The curve increases gradually.


In other words,
\begin{align}
  \notag
  0 &\leqslant \mathrm{d}y \leqslant \mathrm{d}x
\end{align}

*** generic algo

\begin{algorithm}[H]
  \caption{Generic Mid-point Algorithm}
  \DontPrintSemicolon
  \KwIn{$x_0,x_{\mathrm{max}}\in\mathbb{Z}$\hfill\scriptsize
    Start and end x-coordinates.}

  \KwIn{$F:\mathbb{R}^2\to\mathbb{R}$ \hfill
    \scriptsize Signed Distance Function from the curve.}

  \KwOut{$C \equiv
    \{\mathbf{p}_0,\ldots,\mathbf{p}_{\mathrm{max}} \}
    \subset \mathbb{Z}^2$ \hfill \scriptsize Curve in
    discrete 2D space.}

  {$\mathbf{p}_0 \gets \begin{bmatrix} x_0 \\ \lceil
    y_0\rceil \end{bmatrix} \vdash F\left(\begin{matrix}
      x_0 \\ y_0 \end{matrix}\right) = 0$}


\For{$t\in\{1,\ldots,\mathrm{max}\}$}{
  $\mathbf{p}_{\mathrm{mid}}\gets\mathbf{p}_{t-1}+\begin{pmatrix}1\\
    \frac12\end{pmatrix}$

  $\delta_t\gets I[F(\mathbf{p}_{\mathrm{mid}})<0]$

  $\mathbf{p}_{t}\gets\mathbf{p}_{t-1}+\begin{pmatrix}
    1 \\ \delta_{t} \end{pmatrix}$
  }
\end{algorithm}


** Straight Line

*** characterising straight lines

\begin{align*}
  F(x,y)
  &= Ax-By+C \\
  0 \leqslant \mathrm{d}y / \mathrm{d}x \leqslant 1 \quad
  &\mapsto \quad 0 \leqslant A \leqslant B
  &&\textsc{\ldots case 1} \\
  -1 \leqslant \mathrm{d}y / \mathrm{d}x \leqslant 0 \quad
  &\mapsto \quad 0 \leqslant A \leqslant -B
  &&\textsc{\ldots case 2} \\
  0 \leqslant \mathrm{d}x / \mathrm{d}y \leqslant 1 \quad
  &\mapsto \quad 0 \leqslant B \leqslant A
  &&\textsc{\ldots case 3} \\
  -1 \leqslant \mathrm{d}x / \mathrm{d}y \leqslant 0 \quad
  &\mapsto \quad 0 \leqslant -B \leqslant A
  &&\textsc{\ldots case 4}
\end{align*}

[[https://tiet-mca101.github.io/lectures/images/2024-09-02-Note-08-32_annotated.pdf][Read more [...]​]]

*** mid-point algo for st. line

Case 1. $\alert{0<A<B}$

# \usepackage[linesnumbered,ruled,vlined]{algorithm2e}
\begin{algorithm}[H]
  \caption{Mid-Point Algorithm for Straight Line}
  \DontPrintSemicolon

  \Fn(\hfill {\scriptsize Base case.}){\upshape
    \textsc{mid-point-algo-st-line-base}\,
    ($x_1, y_1, N, a, b, c$)}{
    \KwIn{$x_1, y_1, N \in \mathbb{Z} \vdash 0<N$
      \hfill \scriptsize Start coordinates and num
      points.}

    \KwIn{$a,b,c\in\mathbb{Z} \vdash 0\leqslant a < b;
      b\;\mathrm{even}$ \hfill \scriptsize
      Coefficients: $F(x,y)=ax\alert{-by}+c$.}

    \KwOut{$C \equiv
      \{(x_1,y_1),\ldots,(x_N,y_N)
      \} \subset \mathbb{Z}^2$ \\\scriptsize An ordered
      sequence; a curve in discrete 2D space.}
    
    $\delta_1\gets ax_1\alert{-by_1- \frac b2} +c$
    \hfill{\scriptsize $\frac b2\in\mathbb{Z}$ because
      $b$ even.}

    \For{$t\in\{2,\ldots,N\}$}{
      $x_t\gets x_{t-1} + 1$

      $\delta_t\gets \delta_{t-1} + a - b\cdot
      I[0\leqslant\delta_{t-1}]$

      $y_t \gets y_{t-1} + I[0\leqslant\delta_t]$
    }

    \Return{$C \equiv \{(x_1,y_1), \ldots,
      (x_N, y_N) \}$ }

  }
\end{algorithm}

*** mid-point algo for st. line
Case 1. $\alert{0<A<B}$

# \usepackage[linesnumbered,ruled,vlined]{algorithm2e}
\begin{algorithm}[H]
  \caption{Mid-Point Algorithm for Straight Line
    (alternate) \hfill {\scriptsize\textsc{[\ldots
        contd]}}}
  \DontPrintSemicolon
  \KwIn{$x_1, y_1, N\in\mathbb{Z} \vdash 0<N$
    \hfill \scriptsize Start and end x-coordinates.}

  \KwIn{$a,b,c\in\mathbb{Z} \vdash 0\leqslant a < b;
    b\;\mathrm{even}$ \hfill \scriptsize Coefficients:
    $F(x,y)=ax\alert{-by}+c$.}

  \KwOut{$C \equiv
    \{(x_1,y_1),\ldots,(x_N,y_N)
    \} \subset \mathbb{Z}^2$ \\\scriptsize An ordered
    sequence; a curve in discrete 2D space.}

  \textbf{Init:} $C\gets\emptyset$ \hfill {\scriptsize
    Initialise as array.}

  \textbf{Init:} $(x,y,\delta) \gets (x_1, y_1, 0)$
  \hfill {\scriptsize Initialise as integers.}
  
  $\delta\gets ax\alert{-by- \frac b2} +c$
  \hfill{\scriptsize $\frac b2\in\mathbb{Z}$ because
    $b$ even.}

  $C\cdot\textsc{push}\left((x,y)\right)$ \hfill
  {\scriptsize $(x,y)$ is a tuple.}
\end{algorithm}

*** mid-point algo for st. line
Case 1. $\alert{0<A<B}$

# \usepackage[linesnumbered,ruled,vlined]{algorithm2e}
\begin{algorithm}[H]
  \RemoveAlgoNumber
  \setcounter{AlgoLine}{6}
  \caption{{\scriptsize\textsc{[contd \ldots]}}
    Mid-Point Algorithm for Straight Line (alternate)}

  \For{$t\in\{2,\ldots,N\}$}{

    $x\gets x + 1$ \hfill {\scriptsize Increment along
      x-axis.}

    $\delta\gets \delta + a - b\cdot I[0\leqslant\delta]$
    \hfill {\scriptsize Update decision param
      $\delta$.}

    $y \gets y + I[0\leqslant\delta]$ \hfill {\scriptsize
      Update along y-axis based on decision param.}

    $C\cdot\textsc{push}\left((x,y)\right)$ \hfill
    {\scriptsize $(x,y)$ is a tuple.}

  }

  \Return $C$
\end{algorithm}

*** mid-point algo for st. line

Handle all cases (Case 2)
# \usepackage[linesnumbered,ruled,vlined]{algorithm2e}
\begin{algorithm}[H]
  \caption{Mid Point Algorithm for Straight Lines (all
    cases) \hfill {\scriptsize\textsc{[\ldots contd]}}}
  \DontPrintSemicolon

  \Fn(\\ {\scriptsize A wrapper around
    \textsc{mid-point-algo-st-line-base}}){\upshape
    \textsc{mid-point-algo-st-line}\,
    ($x_1,x_{\mathrm{max}},a,b,c$)}{

    \KwIn{$x_1,x_{\mathrm{max}}\in\mathbb{Z} \vdash
      x_1 < x_{\mathrm{max}}$ \hfill\scriptsize Start
      and end x-coordinates.}

    \KwIn{$a,b,c\in\mathbb{Z} \vdash a,b\,
      \mathrm{even}$ \hfill\scriptsize SDF
      $F(x,y) \triangleq ax \alert{-by} +c$.}

    \KwOut{$\mathbb{C} \equiv \{(x_1,y_1), \ldots,
      (x_{\mathrm{max}}, y_{\mathrm{max}})$
      \hfill\scriptsize Collection of points on curve.}

    $(y_1, y_{\mathrm{max}}) \gets \left(
      \lceil\frac{ax_1+c}{b}\rceil,
      \lceil\frac{ax_{\mathrm{max}}+c}{b}\rceil
    \right)$ \hfill {\scriptsize Compute start and end
      y-coordinates.}

    \If(\hfill {\scriptsize \alert{Case 2.}
      $F^{\,\prime} (x,y) = F(x, \alert{-y})$}){$0<a<-b$}{
      % $(x_1^\prime, x_{\mathrm{max}}^\prime, a^\prime,
      % b^\prime, c^\prime) \gets (x_1, x_{\mathrm{max}},
      % a, \alert{-b}, c)$

      % \Fn{Trf($x,y$)}{\Return $(x,\alert{-y})$
      % \hfill{\scriptsize Define inverse
      % transformation.}}      

      $(x_1, y_1, N, a, b, c) \gets
      (x_1, \alert{-y_1}, x_{\mathrm{max}}-x_1\alert{+1}, a,
      \alert{-b}, c)$ \hfill{\scriptsize Flip about
        x-axis.}

      \textbf{define:}
      $\textsc{trf}\, ((x, y)) \mapsto (x,\alert{-y})$
      \hfill{\scriptsize Define inverse
        transformation.}

    }
  }
\end{algorithm}

*** mid-point algo for st. line

Handle all cases (Case 3, 4)
# \usepackage[linesnumbered,ruled,vlined]{algorithm2e}
\begin{algorithm}[H]
  \RemoveAlgoNumber
  \setcounter{AlgoLine}{6}
  \caption{{\scriptsize\textsc{[contd\ldots]}} Mid
    Point Algorithm for Straight Lines (all cases)
    \hfill {\scriptsize\textsc{[\ldots contd]}}}
  \DontPrintSemicolon
  \Cont{
    \ElseIf(\hfill {\scriptsize \alert{Case 3.}
      $F^{\,\prime} (x,y) = F(\alert{-y, -x})$}){$0<b<a$}{

      $(x_1, y_1, N, a, b, c) \gets
      (\alert{-y_{\mathrm{max}}}, \alert{-x_{\mathrm{max}}},
      \alert{-y_1+y_{\mathrm{max}}}+1, \alert{b}, \alert{a},
      c)$ \hfill {\scriptsize Transpose.}

      \textbf{define:}
      $\textsc{trf}\, ((x, y)) \mapsto (\alert{-y},
      \alert{-x})$ \hfill {\scriptsize Define inverse
        transformation.}

    }

    \ElseIf(\hfill {\scriptsize \alert{Case 4.}
      $F^{\,\prime} (x,y) = F(\alert{-y, x})$}){$0<-b<a$}{

      $(x_1, y_1, N, a, b, c) \gets
      (\alert{y_{\mathrm{max}}}, \alert{-x_{\mathrm{max}}},
      \alert{y_1-y_{\mathrm{max}}}+1, \alert{-b}, \alert{a},
      c)$ \hfill {\scriptsize Both flip and transpose.}

      \textbf{define:}
      $\textsc{trf}\, ((x, y)) \mapsto (\alert{-y},
      \alert{x})$ \hfill {\scriptsize Define inverse
        transformation.}

    }
  }
\end{algorithm}

*** mid-point algo for st. line

Handle all cases (Case 1)
# \usepackage[linesnumbered,ruled,vlined]{algorithm2e}
\begin{algorithm}[H]
  \RemoveAlgoNumber
  \setcounter{AlgoLine}{13}
  \caption{{\scriptsize\textsc{[contd\ldots]}} Mid
    Point Algorithm for Straight Lines (all cases)}
  \DontPrintSemicolon
  \Cont{

    \Else(\hfill {\scriptsize \alert{Case
        1. $0<a<b$}}){

      $N\gets x_{\mathrm{max}}-x_1\alert{+1}$

      \textbf{define:}
      $\textsc{trf}\, ((x, y)) \mapsto (x, y)$ \hfill
      {\scriptsize Identity.}

    }

    $C \gets
    \alert{\textsc{mid-point-algo-st-line-base} (x_1,
      y_1, N, a, b, c)}$

    $C\gets\textsc{map}(\textsc{trf}, C)$

    \Return $C$
  }
\end{algorithm}

*** exercise 1

****                                                           :B_columns:
:PROPERTIES:
:BEAMER_env: columns
:END:

*****                                                    :B_column:BMCOL:
:PROPERTIES:
:BEAMER_env: column
:BEAMER_col: .5
:END:

Using Bresenham’s/ Mid-point Algorithm, compute the
points along the following lines, between
1. $(2,0)\to(6,2)$
2. $(0,1)\to(6,13)$
3. $(0,1)\to(6,-2)$
4. $(0,4)\to(6,-8)$

*** solution 1 step 1

For each part, tabulate $a,b,c,
x_1,x_{\max},y_1,y_{\max}, a',b',c',
x_1',x_{\max}',y_1',y_{\max}', N$.

| Part | $x_1$ | $y_1$ | $x_{\max}$ | $y_{\max}$ | $a$ | $b$ | $c$ | $a'$ | $b'$ | $c'$ | $x_1'$ | $y_1'$ | $x_{\max}'$ | $y_{\max}'$ | $N$ |
|------+-------+-------+------------+------------+-----+-----+-----+------+------+------+--------+--------+-------------+-------------+-----|
|    1 |     2 |     0 |          6 |          2 |   1 |   2 |  -2 |    1 |    2 |   -2 |      2 |      0 |           6 |           2 |   5 |
|    2 |     0 |     1 |          6 |         13 |   2 |   1 |   1 |    1 |    2 |    1 |    -13 |     -6 |          -1 |           0 |  13 |
|    3 |     0 |     1 |          6 |         -2 |   1 |  -2 |  -2 |    1 |    2 |   -2 |      0 |     -1 |           6 |           2 |   7 |
|    4 |     0 |     4 |          6 |         -8 |   2 |  -1 |  -4 |    1 |    2 |   -4 |     -8 |     -6 |           4 |           0 |  13 |
|------+-------+-------+------------+------------+-----+-----+-----+------+------+------+--------+--------+-------------+-------------+-----|

*** solution 1 step 2

Compute the table of $x,y,\delta,I[0\leqslant\delta]$
for each iteration from $1$ to $N$.  Subsequently
compute $\textsc{trf}\,(x,y)$.\\
Showing here for part 4.

| $x_1'$ | $y_1'$ | $N$ | $a'$ | $b'$ | $c'$ | $\delta_{1}$ |
|--------+--------+-----+------+------+------+--------------|
|     -8 |     -6 |  13 |    1 |    2 |   -4 |           -1 |


| Iteration                                   |  1 |  2 |  3 |  4 |  5 |  6 |  7 |  8 |  9 | 10 | 11 | 12 | 13 |
|---------------------------------------------+----+----+----+----+----+----+----+----+----+----+----+----+----|
| $x_t'\gets x_{t-1}'+1$                      | -8 | -7 | -6 | -5 | -4 | -3 | -2 | -1 |  0 |  1 |  2 |  3 |  4 |
| $\delta_{t}\gets \delta_{t-1}+a'-b'c_{t-1}$ | -1 |  0 | -1 |  0 | -1 |  0 | -1 |  0 | -1 |  0 | -1 |  0 | -1 |
| $c_{t}\gets I[0\leqslant\delta_{t}]$        |  0 |  1 |  0 |  1 |  0 |  1 |  0 |  1 |  0 |  1 |  0 |  1 |  0 |
| $y_{t}'\gets y_{t-1}'+c_t$                  | -6 | -5 | -5 | -4 | -4 | -3 | -3 | -2 | -2 | -1 | -1 |  0 |  0 |
|---------------------------------------------+----+----+----+----+----+----+----+----+----+----+----+----+----|
| $x\gets -y'$                                |  6 |  5 |  5 |  4 |  4 |  3 |  3 |  2 |  2 |  1 |  1 |  0 |  0 |
| $y\gets x'$                                 | -8 | -7 | -6 | -5 | -4 | -3 | -2 | -1 |  0 |  1 |  2 |  3 |  4 |
#+TBLFM: 

*** exercise 2 (practical)


****                                                           :B_columns:
:PROPERTIES:
:BEAMER_env: columns
:END:

*****                                                    :B_column:BMCOL:
:PROPERTIES:
:BEAMER_env: column
:BEAMER_col: .5
:END:

1. Can the calculations be done using an online
   spreadsheet with formulae?
2. Can the complete algorithm be encoded on a
   spreadsheet?

** Circle

***                                                          :B_againframe:
:PROPERTIES:
:BEAMER_env: againframe
:BEAMER_ref: *generic algo
:BEAMER_act:
:END:

*** mid-point algo for circle
\centering
Coming Soon
